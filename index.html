<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exploración Galáctica</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background-color: #0a0a1a;
        color: #e0e0ff;
        line-height: 1.6;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        text-align: center;
        margin-bottom: 20px;
        padding: 10px;
        background-color: #1a1a3a;
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
      }

      h1 {
        color: #8080ff;
        margin-bottom: 15px;
        text-shadow: 0 0 5px rgba(100, 100, 255, 0.5);
      }

      .info-panel {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
      }

      .energy-display {
        font-size: 1.2rem;
        background-color: #2a2a4a;
        padding: 8px 15px;
        border-radius: 5px;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
      }

      #energy-value {
        font-weight: bold;
        color: #50ff50;
      }

      .controls button {
        background-color: #4040aa;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .controls button:hover {
        background-color: #5050cc;
      }

      .controls button:disabled {
        background-color: #333355;
        cursor: not-allowed;
      }

      /* Añadir estilos para el botón de carga de archivo */
      .load-btn {
        background-color: #4040aa;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .load-btn:hover {
        background-color: #5050cc;
      }

      .main-content {
        display: flex;
        gap: 20px;
      }

      .universe-container {
        flex: 3;
        background-color: #1a1a3a;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        overflow: auto;
      }

      #universe-grid {
        display: grid;
        gap: 1px;
        margin: 0 auto;
      }

      /* Mejorar visualización de celdas */
      .cell {
        width: 20px;
        height: 20px;
        background-color: #2a2a4a;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: rgba(255, 255, 255, 0.7);
        position: relative;
        transition: all 0.3s ease;
        border-radius: 2px;
      }

      .cell:hover {
        transform: scale(1.2);
        z-index: 10;
        box-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
      }

      .cell-info {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px;
        border-radius: 3px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        display: none;
      }

      .cell:hover .cell-info {
        display: block;
      }

      /* Mejorar visualización de tipos de celdas */
      .origin {
        background-color: #00ff00;
        color: black;
        box-shadow: 0 0 8px #00ff00;
      }

      .destination {
        background-color: #ff0000;
        color: white;
        box-shadow: 0 0 8px #ff0000;
      }

      .black-hole {
        background-color: #000000;
        box-shadow: 0 0 8px #000000;
      }

      .giant-star {
        background-color: #ffff00;
        color: black;
        box-shadow: 0 0 8px #ffff00;
        animation: pulse 2s infinite;
      }

      .wormhole {
        background-color: #800080;
        box-shadow: 0 0 8px #800080;
        animation: rotate 3s infinite linear;
      }

      .recharge {
        background-color: #00ffff;
        color: black;
        box-shadow: 0 0 8px #00ffff;
        animation: glow 2s infinite alternate;
      }

      .min-charge {
        background-color: #ff8000;
        color: black;
        box-shadow: 0 0 8px #ff8000;
      }

      .ship {
        background-color: #0080ff;
        box-shadow: 0 0 8px #0080ff;
        z-index: 5;
        animation: throb 1s infinite alternate;
      }

      .path {
        background-color: rgba(0, 128, 255, 0.3);
        box-shadow: 0 0 5px rgba(0, 128, 255, 0.5);
      }

      /* Animaciones */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 5px #00ffff;
        }
        to {
          box-shadow: 0 0 15px #00ffff;
        }
      }

      @keyframes throb {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.2);
        }
      }

      .side-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .legend,
      .log-panel {
        background-color: #1a1a3a;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
      }

      .legend h3,
      .log-panel h3 {
        margin-bottom: 10px;
        color: #8080ff;
        border-bottom: 1px solid #4040aa;
        padding-bottom: 5px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 10px;
        border-radius: 3px;
      }

      #exploration-log {
        height: 300px;
        overflow-y: auto;
        background-color: #2a2a4a;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 0.9rem;
      }

      .log-entry {
        margin-bottom: 5px;
        padding: 3px;
        border-left: 3px solid #4040aa;
        padding-left: 8px;
      }

      .log-success {
        border-left-color: #50ff50;
      }

      .log-error {
        border-left-color: #ff5050;
      }

      .log-info {
        border-left-color: #5050ff;
      }

      /* Añadir estilos para estadísticas */
      .stats-panel {
        background-color: #1a1a3a;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
        box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
      }

      .stats-panel h3 {
        margin-bottom: 10px;
        color: #8080ff;
        border-bottom: 1px solid #4040aa;
        padding-bottom: 5px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        padding: 5px;
        background-color: #2a2a4a;
        border-radius: 5px;
      }

      .stat-label {
        font-weight: bold;
      }

      .stat-value {
        color: #50ff50;
      }

      @media (max-width: 1000px) {
        .main-content {
          flex-direction: column;
        }

        .side-panel {
          flex-direction: row;
        }

        .legend,
        .log-panel {
          flex: 1;
        }
      }

      @media (max-width: 768px) {
        .side-panel {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Exploración Galáctica</h1>
        <div class="info-panel">
          <div class="energy-display">
            <span>Energía: </span>
            <span id="energy-value">200</span>
          </div>
          <div class="controls">
            <button id="start-btn">Iniciar Exploración</button>
            <button id="reset-btn">Reiniciar</button>
            <button id="step-btn" disabled>Siguiente Paso</button>
          </div>
        </div>
      </header>

      <div class="main-content">
        <div class="universe-container">
          <div id="universe-grid"></div>
        </div>

        <div class="side-panel">
          <div class="legend">
            <h3>Leyenda</h3>
            <div class="legend-item">
              <div class="legend-color origin"></div>
              <span>Origen</span>
            </div>
            <div class="legend-item">
              <div class="legend-color destination"></div>
              <span>Destino</span>
            </div>
            <div class="legend-item">
              <div class="legend-color black-hole"></div>
              <span>Agujero Negro</span>
            </div>
            <div class="legend-item">
              <div class="legend-color giant-star"></div>
              <span>Estrella Gigante</span>
            </div>
            <div class="legend-item">
              <div class="legend-color wormhole"></div>
              <span>Agujero de Gusano</span>
            </div>
            <div class="legend-item">
              <div class="legend-color recharge"></div>
              <span>Zona de Recarga</span>
            </div>
            <div class="legend-item">
              <div class="legend-color min-charge"></div>
              <span>Carga Mínima Requerida</span>
            </div>
            <div class="legend-item">
              <div class="legend-color ship"></div>
              <span>Nave</span>
            </div>
            <div class="legend-item">
              <div class="legend-color path"></div>
              <span>Camino Recorrido</span>
            </div>
          </div>

          <div class="log-panel">
            <h3>Registro de Exploración</h3>
            <div id="exploration-log"></div>
          </div>

          <!-- Añadir panel de estadísticas después del panel de registro -->
          <div class="stats-panel">
            <h3>Estadísticas</h3>
            <div class="stat-item">
              <span class="stat-label">Pasos totales:</span>
              <span class="stat-value" id="total-steps">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Agujeros negros destruidos:</span>
              <span class="stat-value" id="destroyed-blackholes">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Agujeros de gusano usados:</span>
              <span class="stat-value" id="used-wormholes">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Recargas de energía:</span>
              <span class="stat-value" id="energy-recharges">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Energía consumida:</span>
              <span class="stat-value" id="energy-consumed">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Tiempo de exploración:</span>
              <span class="stat-value" id="exploration-time">0s</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Clase Universe
      class Universe {
        constructor(data) {
          this.data = data;
          this.grid = document.getElementById("universe-grid");
          this.cells = [];
          this.shipPosition = [...data.origen];
          this.initialEnergy = data.cargaInicial;
          this.currentEnergy = this.initialEnergy;
          this.path = [];

          this.setupGrid();
          this.updateEnergyDisplay();
        }

        setupGrid() {
          const { filas, columnas } = this.data.matriz;

          // Configurar el grid CSS
          this.grid.style.gridTemplateColumns = `repeat(${columnas}, 20px)`;
          this.grid.style.gridTemplateRows = `repeat(${filas}, 20px)`;

          // Crear celdas
          for (let i = 0; i < filas; i++) {
            this.cells[i] = [];
            for (let j = 0; j < columnas; j++) {
              const cell = document.createElement("div");
              cell.className = "cell";
              cell.dataset.row = i;
              cell.dataset.col = j;

              // Mostrar el costo de energía
              const energyCost = this.data.matrizInicial[i][j];
              cell.textContent = energyCost;

              // Crear tooltip con información
              const cellInfo = document.createElement("div");
              cellInfo.className = "cell-info";
              cellInfo.textContent = `[${i},${j}] - Energía: ${energyCost}`;
              cell.appendChild(cellInfo);

              this.grid.appendChild(cell);
              this.cells[i][j] = cell;
            }
          }

          // Aplicar tipos especiales de celdas
          this.applySpecialCells();
        }

        applySpecialCells() {
          const {
            origen,
            destino,
            agujerosNegros,
            estrellasGigantes,
            agujerosGusano,
            zonasRecarga,
            celdasCargaRequerida,
          } = this.data;

          // Origen
          this.setCellType(origen[0], origen[1], "origin");
          this.cells[origen[0]][origen[1]].textContent = "O";

          // Destino
          this.setCellType(destino[0], destino[1], "destination");
          this.cells[destino[0]][destino[1]].textContent = "D";

          // Agujeros Negros
          agujerosNegros.forEach((pos) => {
            this.setCellType(pos[0], pos[1], "black-hole");
            this.cells[pos[0]][pos[1]].textContent = "";
          });

          // Estrellas Gigantes
          estrellasGigantes.forEach((pos) => {
            this.setCellType(pos[0], pos[1], "giant-star");
            this.cells[pos[0]][pos[1]].textContent = "★";
          });

          // Agujeros de Gusano
          agujerosGusano.forEach((wormhole) => {
            const { entrada, salida } = wormhole;
            this.setCellType(entrada[0], entrada[1], "wormhole");
            this.cells[entrada[0]][entrada[1]].textContent = "W";

            // Actualizar tooltip para mostrar la salida
            const cellInfo =
              this.cells[entrada[0]][entrada[1]].querySelector(".cell-info");
            cellInfo.textContent += ` → [${salida[0]},${salida[1]}]`;
          });

          // Zonas de Recarga
          zonasRecarga.forEach((zone) => {
            this.setCellType(zone[0], zone[1], "recharge");
            this.cells[zone[0]][zone[1]].textContent = `x${zone[2]}`;
          });

          // Celdas con Carga Mínima
          celdasCargaRequerida.forEach((cell) => {
            const { coordenada, cargaGastada } = cell;
            this.setCellType(coordenada[0], coordenada[1], "min-charge");
            this.cells[coordenada[0]][coordenada[1]].textContent = cargaGastada;
          });

          // Posición inicial de la nave
          this.updateShipPosition(origen[0], origen[1]);
        }

        setCellType(row, col, type) {
          if (this.isValidCell(row, col)) {
            this.cells[row][col].classList.add(type);

            // Actualizar tooltip
            const cellInfo = this.cells[row][col].querySelector(".cell-info");
            cellInfo.textContent += ` - ${this.getTypeName(type)}`;
          }
        }

        getTypeName(type) {
          const types = {
            origin: "Origen",
            destination: "Destino",
            "black-hole": "Agujero Negro",
            "giant-star": "Estrella Gigante",
            wormhole: "Agujero de Gusano",
            recharge: "Zona de Recarga",
            "min-charge": "Carga Mínima",
            ship: "Nave",
            path: "Camino",
          };
          return types[type] || type;
        }

        updateShipPosition(row, col) {
          // Quitar la nave de la posición anterior
          if (this.shipPosition) {
            const [prevRow, prevCol] = this.shipPosition;
            this.cells[prevRow][prevCol].classList.remove("ship");

            // Marcar como parte del camino si no es el origen
            if (
              !(
                prevRow === this.data.origen[0] &&
                prevCol === this.data.origen[1]
              )
            ) {
              this.cells[prevRow][prevCol].classList.add("path");
            }
          }

          // Actualizar posición
          this.shipPosition = [row, col];
          this.cells[row][col].classList.add("ship");

          // Registrar en el camino
          this.path.push([row, col]);
        }

        moveShip(row, col) {
          // Verificar si es un movimiento válido
          if (!this.isValidMove(row, col)) {
            this.logMessage(`Movimiento inválido a [${row},${col}]`, "error");
            return false;
          }

          // Verificar si es una estrella gigante
          if (this.isGiantStar(row, col)) {
            // Verificar si hay un agujero negro adyacente
            const blackHole = this.canDestroyBlackHole(row, col);
            if (blackHole) {
              // Destruir el agujero negro
              this.destroyBlackHole(blackHole[0], blackHole[1]);
            }
          }

          // Calcular costo de energía
          let energyCost = this.data.matrizInicial[row][col];

          // Verificar si es una zona de recarga
          const rechargeZone = this.findRechargeZone(row, col);
          if (rechargeZone) {
            const multiplier = rechargeZone[2];
            this.currentEnergy *= multiplier;
            this.logMessage(
              `¡Recarga de energía! x${multiplier} → ${this.currentEnergy}`,
              "success"
            );
          } else {
            // Verificar si es una celda con carga mínima requerida
            const minChargeCell = this.findMinChargeCell(row, col);
            if (minChargeCell) {
              const requiredCharge = minChargeCell.cargaGastada;
              if (this.currentEnergy < requiredCharge) {
                this.logMessage(
                  `Energía insuficiente para entrar a [${row},${col}]. Requiere: ${requiredCharge}`,
                  "error"
                );
                return false;
              }
              energyCost = requiredCharge;
            }

            // Restar energía
            this.currentEnergy -= energyCost;
            this.logMessage(
              `Movimiento a [${row},${col}] - Energía: -${energyCost} → ${this.currentEnergy}`,
              "info"
            );
          }

          // Verificar si es un agujero de gusano
          const wormhole = this.findWormhole(row, col);
          if (wormhole) {
            const [exitRow, exitCol] = wormhole.salida;
            this.logMessage(
              `¡Agujero de gusano! [${row},${col}] → [${exitRow},${exitCol}]`,
              "info"
            );

            // Consumir el agujero de gusano
            this.consumeWormhole(row, col);

            // Actualizar posición a la salida del agujero
            row = exitRow;
            col = exitCol;
          }

          // Actualizar posición de la nave
          this.updateShipPosition(row, col);
          this.updateEnergyDisplay();

          // Verificar si llegó al destino
          if (row === this.data.destino[0] && col === this.data.destino[1]) {
            this.logMessage(
              "¡Destino alcanzado! Exploración completada.",
              "success"
            );
            return "destination";
          }

          // Verificar si se quedó sin energía
          if (this.currentEnergy <= 0) {
            this.logMessage(
              "¡Sin energía! La nave no puede continuar.",
              "error"
            );
            return "no-energy";
          }

          return true;
        }

        isValidCell(row, col) {
          const { filas, columnas } = this.data.matriz;
          return row >= 0 && row < filas && col >= 0 && col < columnas;
        }

        isValidMove(row, col) {
          // Verificar si está dentro de los límites
          if (!this.isValidCell(row, col)) {
            return false;
          }

          // Verificar si es un agujero negro
          if (this.isBlackHole(row, col)) {
            return false;
          }

          // Verificar si ya está en el camino (evitar ciclos)
          if (this.path.some((pos) => pos[0] === row && pos[1] === col)) {
            return false;
          }

          return true;
        }

        // Modificar el método isBlackHole para verificar en tiempo real
        isBlackHole(row, col) {
          // Verificar si la celda está en la lista de agujeros negros
          return this.data.agujerosNegros.some(
            (pos) => pos[0] === row && pos[1] === col
          );
        }

        // Añadir método para verificar si una estrella gigante puede destruir un agujero negro adyacente
        canDestroyBlackHole(starRow, starCol) {
          // Verificar las celdas adyacentes (arriba, derecha, abajo, izquierda)
          const adjacentCells = [
            [starRow - 1, starCol], // arriba
            [starRow, starCol + 1], // derecha
            [starRow + 1, starCol], // abajo
            [starRow, starCol - 1], // izquierda
          ];

          // Buscar agujeros negros adyacentes
          const adjacentBlackHoles = adjacentCells.filter(
            ([row, col]) =>
              this.isValidCell(row, col) && this.isBlackHole(row, col)
          );

          return adjacentBlackHoles.length > 0 ? adjacentBlackHoles[0] : null;
        }

        // Añadir método para destruir un agujero negro
        destroyBlackHole(row, col) {
          // Encontrar el índice del agujero negro en el array
          const index = this.data.agujerosNegros.findIndex(
            (pos) => pos[0] === row && pos[1] === col
          );

          if (index !== -1) {
            // Eliminar el agujero negro del array
            this.data.agujerosNegros.splice(index, 1);

            // Actualizar la visualización
            this.cells[row][col].classList.remove("black-hole");
            this.cells[row][col].textContent =
              this.data.matrizInicial[row][col];

            this.logMessage(
              `Agujero negro en [${row},${col}] destruido por una estrella gigante.`,
              "success"
            );
            return true;
          }

          return false;
        }

        // Añadir método para consumir un agujero de gusano
        consumeWormhole(row, col) {
          // Encontrar el índice del agujero de gusano en el array
          const index = this.data.agujerosGusano.findIndex(
            (wormhole) =>
              wormhole.entrada[0] === row && wormhole.entrada[1] === col
          );

          if (index !== -1) {
            // Guardar la información del agujero de gusano antes de eliminarlo
            const wormhole = this.data.agujerosGusano[index];

            // Eliminar el agujero de gusano del array
            this.data.agujerosGusano.splice(index, 1);

            // Actualizar la visualización
            this.cells[row][col].classList.remove("wormhole");
            this.cells[row][col].textContent =
              this.data.matrizInicial[row][col];

            this.logMessage(
              `Agujero de gusano en [${row},${col}] consumido.`,
              "info"
            );

            return wormhole.salida;
          }

          return null;
        }

        // Añadir método para verificar si una celda es una estrella gigante
        isGiantStar(row, col) {
          return this.data.estrellasGigantes.some(
            (pos) => pos[0] === row && pos[1] === col
          );
        }

        findRechargeZone(row, col) {
          return this.data.zonasRecarga.find(
            (zone) => zone[0] === row && zone[1] === col
          );
        }

        findMinChargeCell(row, col) {
          return this.data.celdasCargaRequerida.find(
            (cell) => cell.coordenada[0] === row && cell.coordenada[1] === col
          );
        }

        findWormhole(row, col) {
          return this.data.agujerosGusano.find(
            (wormhole) =>
              wormhole.entrada[0] === row && wormhole.entrada[1] === col
          );
        }

        updateEnergyDisplay() {
          document.getElementById("energy-value").textContent =
            this.currentEnergy.toFixed(0);
        }

        logMessage(message, type = "info") {
          const log = document.getElementById("exploration-log");
          const entry = document.createElement("div");
          entry.className = `log-entry log-${type}`;
          entry.textContent = message;
          log.appendChild(entry);
          log.scrollTop = log.scrollHeight;
        }

        reset() {
          // Limpiar el camino
          this.path.forEach(([row, col]) => {
            this.cells[row][col].classList.remove("path", "ship");
          });

          // Restablecer valores
          this.path = [];
          this.currentEnergy = this.initialEnergy;
          this.updateEnergyDisplay();

          // Colocar la nave en el origen
          this.updateShipPosition(this.data.origen[0], this.data.origen[1]);

          // Limpiar el registro
          document.getElementById("exploration-log").innerHTML = "";
          this.logMessage("Sistema reiniciado.", "info");
        }
      }

      // Clase BacktrackingExplorer
      class BacktrackingExplorer {
        constructor(universe) {
          this.universe = universe;
          this.solution = null;
          this.exploring = false;
          this.stepMode = false;
          this.stepIndex = 0;
          this.steps = [];

          // Estadísticas
          this.stats = {
            totalSteps: 0,
            destroyedBlackHoles: 0,
            usedWormholes: 0,
            energyRecharges: 0,
            energyConsumed: 0,
            explorationTime: 0,
          };
        }

        async findPath() {
          this.exploring = true;
          this.solution = null;
          this.universe.reset();

          // Reiniciar estadísticas
          this.stats = {
            totalSteps: 0,
            destroyedBlackHoles: 0,
            usedWormholes: 0,
            energyRecharges: 0,
            energyConsumed: 0,
            explorationTime: 0,
          };

          const startTime = performance.now();
          this.universe.logMessage(
            "Iniciando exploración con backtracking...",
            "info"
          );

          // Iniciar backtracking desde el origen
          const [startRow, startCol] = this.universe.data.origen;
          const result = await this.backtrack(
            startRow,
            startCol,
            this.universe.initialEnergy,
            []
          );

          const endTime = performance.now();
          this.stats.explorationTime = ((endTime - startTime) / 1000).toFixed(
            2
          );

          if (result) {
            this.universe.logMessage(
              `¡Solución encontrada en ${this.stats.explorationTime} segundos!`,
              "success"
            );
            this.solution = result;

            // Actualizar estadísticas
            this.stats.totalSteps = this.solution.length - 1; // Restar 1 porque el origen no cuenta como paso

            if (!this.stepMode) {
              // Visualizar la solución
              await this.visualizeSolution();
            } else {
              // Preparar los pasos para la visualización paso a paso
              this.prepareSteps();
            }

            // Actualizar panel de estadísticas
            this.updateStatsPanel();
          } else {
            this.universe.logMessage(
              `No se encontró solución después de ${this.stats.explorationTime} segundos.`,
              "error"
            );
          }

          this.exploring = false;
          return result !== null;
        }

        async backtrack(
          row,
          col,
          energy,
          path,
          destroyedBlackHoles = [],
          usedWormholes = []
        ) {
          // Si estamos en modo paso a paso, pausar aquí
          if (this.stepMode) {
            await new Promise((resolve) => setTimeout(resolve, 0));
          }

          // Verificar si hemos llegado al destino
          const [destRow, destCol] = this.universe.data.destino;
          if (row === destRow && col === destCol) {
            return [...path, [row, col]];
          }

          // Verificar si nos quedamos sin energía
          if (energy <= 0) {
            return null;
          }

          // Marcar la posición actual como visitada
          const currentPath = [...path, [row, col]];

          // Verificar si es una estrella gigante
          let localDestroyedBlackHoles = [...destroyedBlackHoles];
          if (this.universe.isGiantStar(row, col)) {
            // Buscar agujeros negros adyacentes
            const blackHole = this.universe.canDestroyBlackHole(row, col);
            if (
              blackHole &&
              !destroyedBlackHoles.some(
                (bh) => bh[0] === blackHole[0] && bh[1] === blackHole[1]
              )
            ) {
              // Añadir a la lista de agujeros negros destruidos
              localDestroyedBlackHoles.push(blackHole);
            }
          }

          // Obtener posibles movimientos (arriba, derecha, abajo, izquierda)
          const moves = [
            [row - 1, col], // arriba
            [row, col + 1], // derecha
            [row + 1, col], // abajo
            [row, col - 1], // izquierda
          ];

          // Intentar cada movimiento
          for (const [nextRow, nextCol] of moves) {
            // Verificar si el movimiento es válido
            if (!this.universe.isValidCell(nextRow, nextCol)) continue;

            // Verificar si es un agujero negro y no ha sido destruido
            if (
              this.universe.isBlackHole(nextRow, nextCol) &&
              !localDestroyedBlackHoles.some(
                (bh) => bh[0] === nextRow && bh[1] === nextCol
              )
            ) {
              continue;
            }

            // Verificar si ya está en el camino (evitar ciclos)
            if (
              currentPath.some(
                (pos) => pos[0] === nextRow && pos[1] === nextCol
              )
            )
              continue;

            // Calcular energía después del movimiento
            let newEnergy = energy;

            // Verificar si es una zona de recarga
            const rechargeZone = this.universe.findRechargeZone(
              nextRow,
              nextCol
            );
            if (rechargeZone) {
              newEnergy *= rechargeZone[2];
            } else {
              // Verificar si es una celda con carga mínima requerida
              const minChargeCell = this.universe.findMinChargeCell(
                nextRow,
                nextCol
              );
              if (minChargeCell) {
                if (newEnergy < minChargeCell.cargaGastada) continue;
                newEnergy -= minChargeCell.cargaGastada;
              } else {
                // Restar el costo de energía normal
                newEnergy -= this.universe.data.matrizInicial[nextRow][nextCol];
              }
            }

            // Verificar si es un agujero de gusano
            const wormhole = this.universe.findWormhole(nextRow, nextCol);
            let wormholeExit = null;
            let localUsedWormholes = [...usedWormholes];

            if (
              wormhole &&
              !usedWormholes.some((w) => w[0] === nextRow && w[1] === nextCol)
            ) {
              wormholeExit = wormhole.salida;
              // Verificar si la salida ya está en el camino
              if (
                currentPath.some(
                  (pos) =>
                    pos[0] === wormholeExit[0] && pos[1] === wormholeExit[1]
                )
              ) {
                continue;
              }
              // Marcar este agujero de gusano como usado
              localUsedWormholes.push([nextRow, nextCol]);
            }

            // Realizar el movimiento recursivamente
            let result;
            if (wormholeExit) {
              // Si es un agujero de gusano, continuar desde la salida
              result = await this.backtrack(
                wormholeExit[0],
                wormholeExit[1],
                newEnergy,
                [...currentPath, [nextRow, nextCol]],
                localDestroyedBlackHoles,
                localUsedWormholes
              );
            } else {
              result = await this.backtrack(
                nextRow,
                nextCol,
                newEnergy,
                currentPath,
                localDestroyedBlackHoles,
                localUsedWormholes
              );
            }

            if (result) {
              return result;
            }
          }

          // No se encontró solución desde esta posición
          return null;
        }

        async visualizeSolution() {
          if (!this.solution) return;

          this.universe.reset();
          this.universe.logMessage("Visualizando solución...", "info");

          // Recorrer el camino de la solución
          for (let i = 0; i < this.solution.length; i++) {
            const [row, col] = this.solution[i];

            // Mover la nave a esta posición
            if (i > 0) {
              // Saltar el origen que ya está colocado
              const result = this.universe.moveShip(row, col);
              if (result === "no-energy") {
                this.universe.logMessage(
                  "Error en la solución: sin energía.",
                  "error"
                );
                break;
              }
            }

            // Pausa para visualización
            await new Promise((resolve) => setTimeout(resolve, 300));
          }

          this.universe.logMessage(
            "Visualización de solución completada.",
            "success"
          );
        }

        prepareSteps() {
          if (!this.solution) return;

          this.steps = [];
          let currentEnergy = this.universe.initialEnergy;

          // Preparar cada paso de la solución
          for (let i = 1; i < this.solution.length; i++) {
            // Empezar desde 1 para saltar el origen
            const [row, col] = this.solution[i];

            // Calcular cambio de energía
            let energyChange = 0;
            let specialAction = null;

            // Verificar si es una zona de recarga
            const rechargeZone = this.universe.findRechargeZone(row, col);
            if (rechargeZone) {
              const oldEnergy = currentEnergy;
              currentEnergy *= rechargeZone[2];
              energyChange = currentEnergy - oldEnergy;
              specialAction = `Recarga x${rechargeZone[2]}`;
            } else {
              // Verificar si es una celda con carga mínima requerida
              const minChargeCell = this.universe.findMinChargeCell(row, col);
              if (minChargeCell) {
                energyChange = -minChargeCell.cargaGastada;
                specialAction = `Carga mínima: ${minChargeCell.cargaGastada}`;
              } else {
                // Costo normal de energía
                energyChange = -this.universe.data.matrizInicial[row][col];
              }
              currentEnergy += energyChange;
            }

            // Verificar si es un agujero de gusano
            const wormhole = this.universe.findWormhole(row, col);
            if (wormhole) {
              specialAction = `Agujero de gusano → [${wormhole.salida[0]},${wormhole.salida[1]}]`;
            }

            // Agregar paso
            this.steps.push({
              position: [row, col],
              energy: currentEnergy,
              energyChange,
              specialAction,
            });
          }

          this.stepIndex = 0;
        }

        async takeStep() {
          if (!this.solution || this.stepIndex >= this.steps.length)
            return false;

          const step = this.steps[this.stepIndex];
          const [row, col] = step.position;

          // Mover la nave a esta posición
          const result = this.universe.moveShip(row, col);

          // Actualizar estadísticas
          if (step.specialAction) {
            if (step.specialAction.includes("Recarga")) {
              this.stats.energyRecharges++;
            } else if (step.specialAction.includes("Agujero de gusano")) {
              this.stats.usedWormholes++;
            } else if (step.specialAction.includes("Agujero negro")) {
              this.stats.destroyedBlackHoles++;
            }
          }

          if (step.energyChange < 0) {
            this.stats.energyConsumed += Math.abs(step.energyChange);
          }

          // Actualizar panel de estadísticas
          this.updateStatsPanel();

          this.stepIndex++;
          return this.stepIndex < this.steps.length;
        }

        enableStepMode() {
          this.stepMode = true;
        }

        disableStepMode() {
          this.stepMode = false;
        }

        // Añadir método para actualizar el panel de estadísticas
        updateStatsPanel() {
          document.getElementById("total-steps").textContent =
            this.stats.totalSteps;
          document.getElementById("destroyed-blackholes").textContent =
            this.stats.destroyedBlackHoles;
          document.getElementById("used-wormholes").textContent =
            this.stats.usedWormholes;
          document.getElementById("energy-recharges").textContent =
            this.stats.energyRecharges;
          document.getElementById("energy-consumed").textContent =
            this.stats.energyConsumed.toFixed(0);
          document.getElementById(
            "exploration-time"
          ).textContent = `${this.stats.explorationTime}s`;
        }
      }

      // Variables globales
      let universeData;
      let universe;
      let explorer;

      // Cargar datos del JSON
      async function loadUniverseData() {
        try {
          // Datos de ejemplo para iniciar
          const jsonData = {
            matriz: {
              filas: 35,
              columnas: 40,
            },
            origen: [0, 0],
            destino: [34, 39],
            agujerosNegros: [
              [3, 5],
              [10, 20],
              [8, 8],
            ],
            estrellasGigantes: [
              [7, 7],
              [14, 14],
              [20, 20],
            ],
            agujerosGusano: [
              { entrada: [11, 11], salida: [13, 13] },
              { entrada: [18, 5], salida: [21, 6] },
            ],
            zonasRecarga: [
              [6, 17, 4],
              [12, 39, 5],
              [28, 20, 3],
              [12, 11, 2],
              [9, 20, 4],
              [20, 10, 4],
              [20, 16, 3],
              [28, 7, 5],
              [9, 7, 3],
              [30, 35, 4],
            ],
            celdasCargaRequerida: [
              { coordenada: [9, 9], cargaGastada: 7 },
              { coordenada: [22, 22], cargaGastada: 12 },
            ],
            cargaInicial: 200,
            matrizInicial: [],
          };

          // Generar matriz inicial con valores aleatorios
          jsonData.matrizInicial = [];
          for (let i = 0; i < jsonData.matriz.filas; i++) {
            const row = [];
            for (let j = 0; j < jsonData.matriz.columnas; j++) {
              row.push(Math.floor(Math.random() * 10) + 1);
            }
            jsonData.matrizInicial.push(row);
          }

          universeData = jsonData;

          // Inicializar el universo
          initializeUniverse();
        } catch (error) {
          console.error("Error al cargar los datos del universo:", error);
          const logElement = document.getElementById("exploration-log");
          if (logElement) {
            logElement.innerHTML =
              '<div class="log-entry log-error">Error al cargar los datos del universo.</div>';
          }
        }
      }

      // Inicializar el universo
      function initializeUniverse() {
        // Crear instancia del universo
        universe = new Universe(universeData);

        // Crear explorador con backtracking
        explorer = new BacktrackingExplorer(universe);

        // Configurar botones
        const startBtn = document.getElementById("start-btn");
        const resetBtn = document.getElementById("reset-btn");
        const stepBtn = document.getElementById("step-btn");

        startBtn.addEventListener("click", async () => {
          if (explorer.exploring) return;

          startBtn.disabled = true;
          stepBtn.disabled = true;

          // Habilitar modo paso a paso
          explorer.enableStepMode();

          // Iniciar exploración
          const success = await explorer.findPath();

          startBtn.disabled = false;
          stepBtn.disabled = !success;
        });

        resetBtn.addEventListener("click", () => {
          universe.reset();
          stepBtn.disabled = true;
        });

        stepBtn.addEventListener("click", async () => {
          if (!explorer.solution) return;

          const hasMoreSteps = await explorer.takeStep();
          stepBtn.disabled = !hasMoreSteps;
        });
      }

      // Función para cargar un archivo JSON
      function loadJSONFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const data = JSON.parse(event.target.result);
              resolve(data);
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = (error) => reject(error);
          reader.readAsText(file);
        });
      }

      // Añadir funcionalidad para cargar archivo JSON
      function setupFileUpload() {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".json";
        fileInput.style.display = "none";
        document.body.appendChild(fileInput);

        // Crear botón para cargar archivo
        const loadBtn = document.createElement("button");
        loadBtn.textContent = "Cargar JSON";
        loadBtn.className = "load-btn";
        loadBtn.onclick = () => fileInput.click();

        // Añadir botón a los controles
        const controls = document.querySelector(".controls");
        controls.prepend(loadBtn);

        // Manejar evento de selección de archivo
        fileInput.addEventListener("change", async (event) => {
          if (event.target.files.length > 0) {
            try {
              const file = event.target.files[0];
              const data = await loadJSONFile(file);

              // Actualizar datos del universo
              universeData = data;

              // Reiniciar el universo con los nuevos datos
              if (universe) {
                universe.reset();
              }

              // Inicializar el universo
              initializeUniverse();

              // Mostrar mensaje de éxito
              const log = document.getElementById("exploration-log");
              log.innerHTML =
                '<div class="log-entry log-success">Archivo JSON cargado correctamente.</div>';
            } catch (error) {
              console.error("Error al cargar el archivo JSON:", error);
              const log = document.getElementById("exploration-log");
              log.innerHTML =
                '<div class="log-entry log-error">Error al cargar el archivo JSON.</div>';
            }
          }
        });
      }

      // Cargar datos al iniciar
      document.addEventListener("DOMContentLoaded", () => {
        loadUniverseData();
        setupFileUpload();
      });
    </script>
  </body>
</html>
